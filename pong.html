<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pong — Play in Browser</title>
  <style>
    :root{--bg:#0b1220;--fg:#e6f0ff;--accent:#7bd389}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071021 0%, #0b1220 100%);color:var(--fg)}
    .wrap{width:min(980px,94vw);max-width:980px;padding:18px;box-sizing:border-box}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
    h1{font-size:18px;margin:0;color:var(--fg)}
    .info{font-size:13px;opacity:.9}
    canvas{display:block;width:100%;height:auto;border-radius:8px;background:#06111b;box-shadow:0 6px 20px rgba(0,0,0,.6)}
    .controls{margin-top:10px;font-size:13px;display:flex;gap:12px;flex-wrap:wrap}
    .controls b{color:var(--accent)}
    footer{margin-top:8px;font-size:12px;color:rgba(230,240,255,.7)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Pong — Play in your browser</h1>
      <div class="info">W/S and ↑/↓ to move • Space to serve • Enter to toggle single-player AI • P to pause</div>
    </header>

    <canvas id="pong" width="800" height="500" aria-label="Pong game canvas"></canvas>

    <div class="controls">
      <div><b>Player 1:</b> W / S</div>
      <div><b>Player 2:</b> Up / Down (or AI)</div>
      <div><b>Space:</b> Serve</div>
      <div><b>Enter:</b> Toggle AI</div>
      <div><b>P:</b> Pause</div>
    </div>

    <footer>Single-file, responsive canvas Pong. Want sound, mobile touch controls, or a better AI? Tell me and I'll update it.</footer>
  </div>

  <script>
    // Simple Pong implementation
    const canvas = document.getElementById('pong');
    const ctx = canvas.getContext('2d');

    // Logical size for crisp scaling
    const WIDTH = 800, HEIGHT = 500;

    let scale = 1;
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      scale = rect.width / WIDTH;
      canvas.height = Math.round(HEIGHT * scale);
      canvas.width = Math.round(WIDTH * scale);
      ctx.setTransform(scale,0,0,scale,0,0);
      draw();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Game state
    const paddle = {w:10, h:100, speed: 6};
    const left = {x: 20, y: (HEIGHT-100)/2, score: 0};
    const right = {x: WIDTH-20-10, y: (HEIGHT-100)/2, score: 0};
    const ball = {x: WIDTH/2, y: HEIGHT/2, r:8, speed: 6, velX: 0, velY: 0};

    let upPressed=false, downPressed=false, wPressed=false, sPressed=false;
    let running = true;
    let serving = true; // waiting to serve
    let aiEnabled = true;

    // Reset ball to center and prepare to serve toward the last scorer (or random)
    function resetBall(servingToRight=true) {
      ball.x = WIDTH/2; ball.y = HEIGHT/2;
      ball.speed = 6;
      const angle = (Math.random() * Math.PI/3) - Math.PI/6; // -30 to +30 degrees
      ball.velX = (servingToRight ? 1 : -1) * ball.speed * Math.cos(angle);
      ball.velY = ball.speed * Math.sin(angle);
      serving = true;
    }

    // Initial serve to random side
    resetBall(Math.random() > 0.5);

    // Draw helpers
    function drawRect(x,y,w,h,fill=true){
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      fill ? ctx.fill() : ctx.stroke();
      ctx.closePath();
    }
    function drawCircle(x,y,r){
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
      ctx.closePath();
    }
    function drawNet(){
      const dash = 12, gap = 8; let y=0;
      ctx.lineWidth = 2;
      ctx.setLineDash([dash,gap]);
      ctx.beginPath();
      ctx.moveTo(WIDTH/2,0);
      ctx.lineTo(WIDTH/2,HEIGHT);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function draw(){
      // background
      ctx.fillStyle = '#06111b';
      drawRect(0,0,WIDTH,HEIGHT);

      // net
      ctx.strokeStyle = 'rgba(230,240,255,0.08)';
      drawNet();

      // paddles
      ctx.fillStyle = '#e6f0ff';
      drawRect(left.x, left.y, paddle.w, paddle.h);
      drawRect(right.x, right.y, paddle.w, paddle.h);

      // ball
      drawCircle(ball.x, ball.y, ball.r);

      // scores
      ctx.fillStyle = 'rgba(230,240,255,0.9)';
      ctx.font = '48px system-ui, -apple-system, "Segoe UI", Roboto';
      ctx.textAlign = 'center';
      ctx.fillText(left.score, WIDTH*0.25, 60);
      ctx.fillText(right.score, WIDTH*0.75, 60);

      // paused / serving message
      ctx.font = '18px system-ui';
      ctx.textAlign = 'center';
      if(!running){ ctx.fillText('Paused', WIDTH/2, HEIGHT/2 - 30); }
      else if(serving){ ctx.fillText('Press SPACE to serve', WIDTH/2, HEIGHT/2 - 30); }

      // footer small
      ctx.font = '12px system-ui';
      ctx.textAlign = 'right';
      ctx.fillStyle = 'rgba(230,240,255,0.4)';
      ctx.fillText('Single-file Pong — Toggle AI with Enter', WIDTH-12, HEIGHT-8);
    }

    // Game update
    function update() {
      if(!running) return;

      // Player input movement
      if(wPressed) left.y -= paddle.speed;
      if(sPressed) left.y += paddle.speed;
      if(upPressed) right.y -= paddle.speed;
      if(downPressed) right.y += paddle.speed;

      // Constrain paddles
      left.y = Math.max(0, Math.min(HEIGHT - paddle.h, left.y));
      right.y = Math.max(0, Math.min(HEIGHT - paddle.h, right.y));

      // AI for right paddle if enabled
      if(aiEnabled){
        const target = ball.y - (paddle.h/2);
        const diff = target - right.y;
        // simple smoothing
        if(Math.abs(diff) > 6) right.y += Math.sign(diff) * Math.min(5, Math.abs(diff));
      }

      // Ball movement
      if(!serving){
        ball.x += ball.velX;
        ball.y += ball.velY;
      }

      // Top/bottom collision
      if(ball.y - ball.r < 0){ ball.y = ball.r; ball.velY *= -1; }
      if(ball.y + ball.r > HEIGHT){ ball.y = HEIGHT - ball.r; ball.velY *= -1; }

      // Paddle collisions
      // Left paddle
      if(ball.x - ball.r <= left.x + paddle.w && ball.x - ball.r > left.x){
        if(ball.y >= left.y && ball.y <= left.y + paddle.h){
          ball.x = left.x + paddle.w + ball.r; // nudge out
          reflectFromPaddle(left);
        }
      }
      // Right paddle
      if(ball.x + ball.r >= right.x && ball.x + ball.r < right.x + paddle.w){
        if(ball.y >= right.y && ball.y <= right.y + paddle.h){
          ball.x = right.x - ball.r;
          reflectFromPaddle(right);
        }
      }

      // Score
      if(ball.x + ball.r < 0){ // right scores
        right.score += 1;
        resetBall(true);
      }
      if(ball.x - ball.r > WIDTH){ // left scores
        left.score += 1;
        resetBall(false);
      }
    }

    function reflectFromPaddle(p) {
      // Determine where on paddle the ball hit
      const relativeIntersectY = (p.y + paddle.h/2) - ball.y;
      const normalized = relativeIntersectY / (paddle.h/2); // -1..1
      // Bounce angle up to 75 degrees
      const maxBounce = (5 * Math.PI) / 12; // 75deg
      const bounceAngle = normalized * maxBounce;

      const direction = (p === left) ? 1 : -1;
      ball.speed = Math.min(12, ball.speed + 0.4); // increase speed slightly
      ball.velX = direction * ball.speed * Math.cos(bounceAngle);
      ball.velY = - ball.speed * Math.sin(bounceAngle);
    }

    // Input
    window.addEventListener('keydown', e => {
      if(e.key === 'ArrowUp'){ upPressed = true; }
      if(e.key === 'ArrowDown'){ downPressed = true; }
      if(e.key === 'w' || e.key === 'W'){ wPressed = true; }
      if(e.key === 's' || e.key === 'S'){ sPressed = true; }
      if(e.code === 'Space'){
        if(serving){ serving = false; }
        e.preventDefault();
      }
      if(e.key === 'Enter'){
        aiEnabled = !aiEnabled;
      }
      if(e.key === 'p' || e.key === 'P'){
        running = !running;
      }
    });
    window.addEventListener('keyup', e => {
      if(e.key === 'ArrowUp'){ upPressed = false; }
      if(e.key === 'ArrowDown'){ downPressed = false; }
      if(e.key === 'w' || e.key === 'W'){ wPressed = false; }
      if(e.key === 's' || e.key === 'S'){ sPressed = false; }
    });

    // Mouse / touch to move left paddle (optional convenience)
    let dragging = false;
    canvas.addEventListener('pointerdown', e => {
      dragging = true; movePaddleToPointer(e);
    });
    canvas.addEventListener('pointermove', e => {
      if(dragging){ movePaddleToPointer(e); }
    });
    canvas.addEventListener('pointerup', () => dragging = false);
    canvas.addEventListener('pointercancel', () => dragging = false);

    function movePaddleToPointer(e){
      const rect = canvas.getBoundingClientRect();
      const y = (e.clientY - rect.top) / scale; // transform to logical coordinates
      left.y = Math.max(0, Math.min(HEIGHT-paddle.h, y - paddle.h/2));
    }

    // Game loop
    function loop(){
      update();
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Prevent arrow keys from scrolling the page when canvas focused
    window.addEventListener('keydown', function(e) {
      if(['ArrowUp','ArrowDown','Space'].includes(e.key)) e.preventDefault();
    });

    // Touch-friendly restart button via double-tap
    let lastTap = 0;
    canvas.addEventListener('touchend', (e) => {
      const now = Date.now();
      if(now - lastTap < 300){ // double-tap
        left.score = right.score = 0;
        resetBall(Math.random() > 0.5);
      }
      lastTap = now;
    });

    // Draw initial frame
    draw();

  </script>
</body>
</html>
